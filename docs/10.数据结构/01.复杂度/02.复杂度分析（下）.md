---
title: 时间空间复杂度分析（下）
date: 2020-11-04 15:03:29
# permalink: /pages/8143cc480faf9a11
categories: 
  - 数据结构
tags: 
  - 复杂度
author: 
  name: yangxin
  link: https://github.com/yangxin6/data_structure
---


在一个无序的数组（array）中，查找变量 x 出现的位置。如果没有找到，就返回 -1
```c

// n表示数组array的长度
int find(int[] array, int n, int x) {
  int i = 0;
  int pos = -1;
  for (; i < n; ++i) {
    if (array[i] == x) pos = i;
  }
  return pos;
}
```
优化之后

```c

// n表示数组array的长度
int find(int[] array, int n, int x) {
  int i = 0;
  int pos = -1;
  for (; i < n; ++i) {
    if (array[i] == x) {
       pos = i;
       break;
    }
  }
  return pos;
}
```
为了表示代码在不同情况下的不同时间复杂度，引入三个概念：
- 最好情况时间复杂度
- 最坏情况时间复杂度
- 平均时间复杂度

# 最好情况时间复杂度
最好情况时间复杂度就是，在最理想的情况下，执行这段代码的时间复杂度
# 最坏情况时间复杂度
最坏情况时间复杂度就是，在最糟糕的情况下，执行这段代码的时间复杂度
# 平均情况时间复杂度
要查找的变量 x 在数组中的位置，有 n+1 种情况：在数组的 0～n-1 位置中和不在数组中。我们把每种情况下，查找需要遍历的元素个数累加起来，然后再除以 n+1，就可以得到需要遍历的元素个数的平均值：
![1](https://cdn.jsdelivr.net/gh/yangxin6/img-hosting@master/images/1.3s14fssqy6m0.jpeg)
时间复杂度的大 O 标记法中，可以省略掉系数、低阶、常量，所以，咱们把刚刚这个公式简化之后，得到的平均时间复杂度就是 O(n)。

但是：n+1 种情况，出现的概率并不是一样的。

（1）在数组中与不在数组中的概率都为 1/2。
（2）要查找的数据出现在 0～n-1 这 n 个位置的概率也是一样的，为 1/n。
（3）所以，根据概率乘法法则，要查找的数据出现在 0～n-1 中任意位置的概率就是 1/(2n)。

因此，前面的推导过程中存在的最大问题就是，没有将各种情况发生的概率考虑进去。如果我们把每种情况发生的概率也考虑进去，那平均时间复杂度的计算过程就变成了这样：
![2](https://cdn.jsdelivr.net/gh/yangxin6/img-hosting@master/images/2.4unmr16ilmo0.png)
这个值就是概率论中的**加权平均值**，也叫作**期望值**，所以平均时间复杂度的全称应该叫**加权平均时间复杂度**或者**期望时间复杂度**。


引入概率之后，前面那段代码的加权平均值为 (3n+1)/4。用大 O 表示法来表示，去掉系数和常量，这段代码的加权平均时间复杂度仍然是 O(n)。

在大多数情况下，我们并不需要区分最好、最坏、平均情况时间复杂度三种情况。只有同一块代码在不同的情况下，时间复杂度有量级的差距，我们才会使用这三种复杂度表示法来区分
# 均摊时间复杂度
例子：

```c
 // array表示一个长度为n的数组
 // 代码中的array.length就等于n
 int[] array = new int[n];
 int count = 0;
 
 void insert(int val) {
    if (count == array.length) {
       int sum = 0;
       for (int i = 0; i < array.length; ++i) {
          sum = sum + array[i];
       }
       array[0] = sum;
       count = 1;
    }

    array[count] = val;
    ++count;
 }
```
最好时间复杂度：O(1)
最坏时间复杂度：O(n)
平均时间复杂度：
假设数组的长度是 n，根据数据插入的位置的不同，我们可以分为 n 种情况，每种情况的时间复杂度是 O(1)。
除此之外，还有一种“额外”的情况，就是在数组没有空闲空间时插入一个数据，这个时候的时间复杂度是 O(n)。
而且，这 n+1 种情况发生的概率一样，都是 1/(n+1)。
所以，根据加权平均的计算方法，我们求得的平均时间复杂度就是：![3](https://cdn.jsdelivr.net/gh/yangxin6/img-hosting@master/images/3.4nw88pye34m0.jpeg)

`find()`和`insert()` 区别：
- `find()`函数，在极端情况下，复杂度才为 O(1)。但 insert() 在大部分情况下，时间复杂度都为 O(1)。只有个别情况下，复杂度才比较高，为 O(n)。
- `insert()`函数，O(1) 时间复杂度的插入和 O(n) 时间复杂度的插入，出现的频率是非常有规律的，而且有一定的前后时序关系，一般都是一个 O(n) 插入之后，紧跟着 n-1 个 O(1) 的插入操作，循环往复。

针对这种特殊的场景，我们引入了一种更加简单的分析方法：**摊还分析法**，通过摊还分析得到的时间复杂度我们起了一个名字，叫**均摊时间复杂度**。

每一次 O(n) 的插入操作，都会跟着 n-1 次 O(1) 的插入操作，所以把耗时多的那次操作均摊到接下来的 n-1 次耗时少的操作上，均摊下来，这一组连续的操作的均摊时间复杂度就是 O(1)

## 应用场景
对一个数据结构进行一组连续操作中，大部分情况下时间复杂度都很低，只有个别情况下时间复杂度比较高，而且这些操作之间存在前后连贯的时序关系，这个时候，我们就可以将这一组操作放在一块儿分析，看是否能将较高时间复杂度那次操作的耗时，平摊到其他那些时间复杂度比较低的操作上。而且，在能够应用均摊时间复杂度分析的场合，一般均摊时间复杂度就等于最好情况时间复杂度。

**均摊时间复杂度就是一种特殊的平均时间复杂度**

# 小结
同一段代码，在不同输入的情况下，复杂度量级有可能是不一样。
引入 **最好情况时间复杂度、最坏情况时间复杂度、平均情况时间复杂度、均摊时间复杂度** 来更加全面地表示一段代码的执行效率。

# 思考

```c

// 全局变量，大小为10的数组array，长度len，下标i。
int array[] = new int[10]; 
int len = 10;
int i = 0;

// 往数组中添加一个元素
void add(int element) {
   if (i >= len) { // 数组空间不够了
     // 重新申请一个2倍大小的数组空间
     int new_array[] = new int[len*2];
     // 把原来array数组中的数据依次copy到new_array
     for (int j = 0; j < len; ++j) {
       new_array[j] = array[j];
     }
     // new_array复制给array，array现在大小就是2倍len了
     array = new_array;
     len = 2 * len;
   }
   // 将element放到下标为i的位置，下标i加一
   array[i] = element;
   ++i;
}
```
最好时间复杂度：O(1)
最坏时间复杂度：O(n)
均摊时间复杂度：O(1)，和均摊时间复杂度的运用场景很类似：大部分情况时间复杂度都很低，只有个别情况下时间复杂度比较高，每次O(10)之后，接着就是 9 次 O(1)，可以将这次复杂度较高的操作，均摊到每次复杂度低的操作上。均摊时间复杂度等于最好情况时间复杂度O(1)。


