(window.webpackJsonp=window.webpackJsonp||[]).push([[46],{481:function(s,t,a){"use strict";a.r(t);var n=a(24),r=Object(n.a)({},(function(){var s=this,t=s.$createElement,a=s._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[a("h1",{attrs:{id:"定义"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#定义"}},[s._v("#")]),s._v(" 定义")]),s._v(" "),a("p",[a("strong",[s._v("数组")]),s._v("（Array）是一种"),a("strong",[s._v("线性表")]),s._v("数据结构。它用一组"),a("strong",[s._v("连续的内存空间")]),s._v("，来存储一组具有"),a("strong",[s._v("相同类型")]),s._v("的数据。")]),s._v(" "),a("ul",[a("li",[a("strong",[s._v("线性表")]),s._v("\n数组、链表、队列、栈\n"),a("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/yangxin6/img-hosting@master/images/1.42bn5s5da3c0.jpeg",alt:"1"}})]),s._v(" "),a("li",[a("strong",[s._v("非线性表")]),s._v(" "),a("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/yangxin6/img-hosting@master/images/2.73e6vf32sq00.jpeg",alt:"2"}})])]),s._v(" "),a("h1",{attrs:{id:"随机访问"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#随机访问"}},[s._v("#")]),s._v(" 随机访问")]),s._v(" "),a("p",[a("strong",[s._v("连续的内存空间和相同类型的数据")]),s._v("。正是因为这两个限制，它才有了一个堪称“杀手锏”的特性：“"),a("strong",[s._v("随机访问")]),s._v("”。但有利就有弊，这两个限制也让数组的很多操作变得非常"),a("strong",[s._v("低效")]),s._v("，比如要想在数组中"),a("strong",[s._v("删除、插入")]),s._v("一个数据，为了保证连续性，就需要做大量的数据搬移工作。")]),s._v(" "),a("ul",[a("li",[s._v("short \t\t2字节\t\t16位整数")]),s._v(" "),a("li",[s._v("int     \t\t4 字节 \t\t32位整数")]),s._v(" "),a("li",[s._v("long\t\t8字节 \t\t64位整数")])]),s._v(" "),a("p",[s._v("int[] a = new int[10]，分配了一块连续内存空间 1000～1039，其中，内存块的首地址为 base_address = 1000。\n"),a("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/yangxin6/img-hosting@master/images/3.g32ze0qcl9c.jpeg",alt:"3"}}),s._v("\n寻址公式")]),s._v(" "),a("div",{staticClass:"language-c line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-c"}},[a("code",[s._v("a"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("[")]),s._v("i"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("]")]),s._v("_address "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" base_address "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("+")]),s._v(" i "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),s._v(" data_type_size\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br")])]),a("p",[a("strong",[s._v("数组和链表的区别")]),s._v("：")]),s._v(" "),a("ul",[a("li",[s._v("链表适合插入、删除，时间复杂度 O(1)")]),s._v(" "),a("li",[s._v("数组支持随机访问，根据下标随机访问的时间复杂度为 O(1)")])]),s._v(" "),a("p",[s._v("注：数组是适合查找操作，但是查找的时间复杂度并不为 O(1)。即便是排好序的数组，你用二分查找，时间复杂度也是 O(logn)。")]),s._v(" "),a("h1",{attrs:{id:"低效的-插入-和-删除"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#低效的-插入-和-删除"}},[s._v("#")]),s._v(" 低效的“插入”和“删除”")]),s._v(" "),a("h2",{attrs:{id:"插入"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#插入"}},[s._v("#")]),s._v(" 插入")]),s._v(" "),a("p",[s._v("假设数组的长度为 n，现在，如果我们需要将一个数据插入到数组中的第 k 个位置。为了把第 k 个位置腾出来，给新来的数据，我们需要将第 k～n 这部分的元素都顺序地往后挪一位。")]),s._v(" "),a("ul",[a("li",[s._v("在数组"),a("strong",[s._v("末尾")]),s._v("插入元素，不需要移动数据，时间复杂度为"),a("strong",[s._v("O(1)")]),s._v("。")]),s._v(" "),a("li",[s._v("在数组"),a("strong",[s._v("开头")]),s._v("插入元素，所有的数据都需要依次往后移动一位，所以最坏时间复杂度是 "),a("strong",[s._v("O(n)")]),s._v("。\n在每个位置插入元素的概率是一样，"),a("strong",[s._v("平均时间复杂度")]),s._v("：(1+2+…n)/n=O(n)。")]),s._v(" "),a("li",[s._v("如果数组"),a("strong",[s._v("数据有序")]),s._v("，需要按照刚才的方法搬移 k 之后的数据。")]),s._v(" "),a("li",[s._v("如果数组中存储的数据并"),a("strong",[s._v("没有任何规律")]),s._v("，数组只是被当作一个存储数据的集合。\n直接将第 k 位的数据搬移到数组元素的最后，把新的元素直接放入第 k 个位置。")])]),s._v(" "),a("p",[a("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/yangxin6/img-hosting@master/images/4.3b4imespzv00.jpeg",alt:"4"}}),s._v("\n利用这种处理技巧，"),a("strong",[s._v("在特定场景下")]),s._v("，在第 k 个位置插入一个元素的时间复杂度就会降为 O(1)。")]),s._v(" "),a("h2",{attrs:{id:"删除"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#删除"}},[s._v("#")]),s._v(" 删除")]),s._v(" "),a("p",[s._v("跟插入数据类似，如果我们要删除第 k 个位置的数据，为了内存的连续性，也"),a("strong",[s._v("需要搬移数据")]),s._v("，不然中间就会出现空洞，内存就不连续了。")]),s._v(" "),a("ul",[a("li",[s._v("删除数组末尾的数据，则最好情况时间复杂度为 O(1)")]),s._v(" "),a("li",[s._v("如果删除开头的数据，则最坏情况时间复杂度为 O(n)")]),s._v(" "),a("li",[s._v("平均情况时间复杂度也为 O(n)")])]),s._v(" "),a("p",[s._v("在某些特殊场景下，我们并"),a("strong",[s._v("不一定非得追求数组中数据的连续性")]),s._v("。将多次删除操作集中在一起执行，来提高删除的效率。\n"),a("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/yangxin6/img-hosting@master/images/5.4uupywm4w2g0.jpeg",alt:"5"}}),s._v("\n为了避免 d，e，f，g，h 这几个数据会被搬移三次，我们可以先记录下已经删除的数据。\n每次的删除操作并"),a("strong",[s._v("不是真正地搬移数据")]),s._v("，只是"),a("strong",[s._v("记录数据已经被删除")]),s._v("。\n当数组没"),a("strong",[s._v("有更多空间存储数据")]),s._v("时，我们"),a("strong",[s._v("再触发执行一次真正的删除")]),s._v("操作，这样就大大减少了删除操作导致的数据搬移。")]),s._v(" "),a("h1",{attrs:{id:"数组越界"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#数组越界"}},[s._v("#")]),s._v(" 数组越界")]),s._v(" "),a("div",{staticClass:"language-c line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-c"}},[a("code",[s._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("int")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("main")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("int")]),s._v(" argc"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("char")]),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),s._v(" argv"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("[")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("int")]),s._v(" i "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("int")]),s._v(" arr"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("[")]),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("3")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("]")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("for")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v(" i"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("<=")]),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("3")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v(" i"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("++")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n        arr"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("[")]),s._v("i"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("]")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n        "),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("printf")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[s._v('"hello world\\n"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("return")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br")])]),a("p",[s._v("i = 3 访问越界。数组越界在 C 语言中是一种未决行为，并没有规定数组访问越界时编译器应该如何处理。\n因为，访问数组的本质就是访问一段连续内存，只要数组通过偏移计算得到的内存地址是可用的，那么程序就可能不会报任何错误。")]),s._v(" "),a("h2",{attrs:{id:"容器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#容器"}},[s._v("#")]),s._v(" 容器")]),s._v(" "),a("p",[s._v("针对数组类型，很多语言都提供了容器类，比如 Java 中的 "),a("strong",[s._v("ArrayList")]),s._v("、C++ STL 中的 "),a("strong",[s._v("vector")]),s._v("。")]),s._v(" "),a("p",[a("strong",[s._v("ArrayList")]),s._v(" 最大的优势就是可以"),a("strong",[s._v("将很多数组操作的细节封装起来")]),s._v("。比如前面提到的数组插入、删除数据时需要搬移其他数据等。另外，它还有一个优势，就是支持"),a("strong",[s._v("动态扩容")]),s._v("。")]),s._v(" "),a("p",[s._v("数组本身在定义的时候需要预先指定大小，因为需要分配连续的内存空间。如果我们申请了大小为 10 的数组，当第 11 个数据需要存储到数组中时，我们就需要"),a("strong",[s._v("重新分配")]),s._v("一块更大的空间，将原来的数据"),a("strong",[s._v("复制")]),s._v("过去，然后再将"),a("strong",[s._v("新的数据插入")]),s._v("。")]),s._v(" "),a("p",[s._v("使用 ArrayList，不需要关心底层的扩容逻辑，ArrayList 已经实现好了。每次存储空间不够的时候，它都会将空间自动"),a("strong",[s._v("扩容为 1.5 倍")]),s._v("大小。")]),s._v(" "),a("p",[a("strong",[s._v("注意："),a("strong",[s._v("扩容操作涉及")]),s._v("内存申请")]),s._v("和"),a("strong",[s._v("数据搬移")]),s._v("，是比较"),a("strong",[s._v("耗时")]),s._v("的。所以，如果事先能确定需要存储的数据大小，"),a("strong",[s._v("最好在创建 ArrayList 的时候事先指定数据大小")]),s._v("。")]),s._v(" "),a("h1",{attrs:{id:"更适合使用数组的地方"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#更适合使用数组的地方"}},[s._v("#")]),s._v(" 更适合使用数组的地方：")]),s._v(" "),a("ol",[a("li",[s._v("Java ArrayList 无法存储基本类型，比如 int、long，需要封装为 Integer、Long 类，而 Autoboxing、Unboxing 则有一定的性能消耗，所以如果特别关注性能，或者希望使用基本类型，就可以选用数组。")]),s._v(" "),a("li",[s._v("如果数据大小事先已知，并且对数据的操作非常简单，用不到 ArrayList 提供的大部分方法，也可以直接使用数组。")]),s._v(" "),a("li",[s._v("表示多维数组时，用数组往往会更加直观。比如 Object[][] array；而用容器的话则需要这样定义："),a("code",[s._v("ArrayList<ArrayList<object>> array")]),s._v("。")])]),s._v(" "),a("h1",{attrs:{id:"数组下标从0开始"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#数组下标从0开始"}},[s._v("#")]),s._v(" 数组下标从0开始")]),s._v(" "),a("ul",[a("li",[s._v("从数组存储的内存模型上来看，“下标”最确切的定义应该是“偏移（offset）”\n计算 a[k]的内存地址:")])]),s._v(" "),a("div",{staticClass:"language-c line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-c"}},[a("code",[s._v("a"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("[")]),s._v("k"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("]")]),s._v("_address "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" base_address "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("+")]),s._v(" k "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),s._v(" type_size\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br")])]),a("p",[s._v("如果数组从 1 开始计数，那我们计算数组元素 a[k]的内存地址就会变为：")]),s._v(" "),a("div",{staticClass:"language-c line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-c"}},[a("code",[s._v("a"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("[")]),s._v("k"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("]")]),s._v("_address "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" base_address "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("+")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("k"),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("-")]),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),s._v("type_size\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br")])]),a("p",[s._v("从 1 开始编号，每次随机访问数组元素都多了一次减法运算，对于 CPU 来说，就是多了一次减法指令。")]),s._v(" "),a("p",[s._v("更多的是历史原因：\nC 语言设计者用 0 开始计数数组下标，之后的 Java、JavaScript 等高级语言都效仿了 C 语言，或者说，为了在一定程度上减少 C 语言程序员学习 Java 的学习成本，因此继续沿用了从 0 开始计数的习惯。实际上，很多语言中数组也并不是从 0 开始计数的，比如 Matlab。甚至还有一些语言支持负数下标，比如 Python。")]),s._v(" "),a("h1",{attrs:{id:"小结"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#小结"}},[s._v("#")]),s._v(" 小结")]),s._v(" "),a("p",[a("strong",[s._v("数组")]),s._v("用一块"),a("strong",[s._v("连续")]),s._v("的内存空间，来存储相同类型的一组数据，最大的特点就是支持"),a("strong",[s._v("随机访问")]),s._v("，但"),a("strong",[s._v("插入、删除")]),s._v("操作也因此变得比较"),a("strong",[s._v("低效")]),s._v("，"),a("strong",[s._v("平均情况时间复杂度")]),s._v("为 O(n)。在平时的业务开发中，我们可以直接使用编程语言提供的容器类，但是，如果是特别"),a("strong",[s._v("底层的开发")]),s._v("，直接使用数组可能会更合适。")]),s._v(" "),a("h1",{attrs:{id:"思考"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#思考"}},[s._v("#")]),s._v(" 思考")]),s._v(" "),a("h2",{attrs:{id:"jvm-标记清楚垃圾回收算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#jvm-标记清楚垃圾回收算法"}},[s._v("#")]),s._v(" JVM 标记清楚垃圾回收算法")]),s._v(" "),a("p",[s._v("大多数主流虚拟机采用"),a("strong",[s._v("可达性分析算法")]),s._v("来判断对象是否存活，在标记阶段，会遍历所有 GC ROOTS，将所有 GC ROOTS 可达的对象标记为存活。只有当标记工作完成后，清理工作才会开始。")]),s._v(" "),a("p",[s._v("不足：")]),s._v(" "),a("ol",[a("li",[s._v("效率问题。标记和清理效率都不高，但是当知道只有少量垃圾产生时会很高效。")]),s._v(" "),a("li",[s._v("空间问题。会产生不连续的内存空间碎片。")])]),s._v(" "),a("h2",{attrs:{id:"二维数组内存寻址"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#二维数组内存寻址"}},[s._v("#")]),s._v(" 二维数组内存寻址")]),s._v(" "),a("p",[s._v("对于 m * n 的数组，"),a("code",[s._v("a [ i ][ j ] (i < m,j < n)")]),s._v("的地址为：")]),s._v(" "),a("div",{staticClass:"language-c line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-c"}},[a("code",[s._v("address "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" base_address "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("+")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v(" i "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),s._v(" n "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("+")]),s._v(" j"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),s._v(" type_size\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br")])]),a("h2",{attrs:{id:"死循环问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#死循环问题"}},[s._v("#")]),s._v(" 死循环问题")]),s._v(" "),a("p",[s._v("待解决")])])}),[],!1,null,null,null);t.default=r.exports}}]);